use std::{
    cell::{Cell, RefCell},
    rc::Rc,
};
pub fn cell_refcell() {
    // Cell 和 RefCell
    // Rust 的编译器之严格，可以说是举世无双。特别是在所有权方面，Rust 通过严格的规则来保证所有权和借用的正确性，最终为程序的安全保驾护航。
    // 但是严格是一把双刃剑，带来安全提升的同时，损失了灵活性，有时甚至会让用户痛苦不堪、怨声载道。因此 Rust 提供了 Cell 和 RefCell 用于内部可变性，简而言之，可以在拥有不可变引用的同时修改目标数据，对于正常的代码实现来说，这个是不可能做到的（要么一个可变借用，要么多个不可变借用）。
    // 内部可变性的实现是因为 Rust 使用了 unsafe 来做到这一点，但是对于使用者来说，这些都是透明的，因为这些不安全代码都被封装到了安全的 API 中

    // Cell
    // Cell 和 RefCell 在功能上没有区别，区别在于 Cell<T> 适用于 T 实现 Copy 的情况：
    let c = Cell::new("asdf");
    let one = c.get();
    c.set("qwer1s");
    let two = c.get();
    println!("{},{}", one, two);

    // 以上代码展示了 Cell 的基本用法，有几点值得注意：
    // 1. "asdf" 是 &str 类型，它实现了 Copy 特征
    // 2. c.get 用来取值，c.set 用来设置新值

    // 取到值保存在 one 变量后，还能同时进行修改，这个违背了 Rust 的借用规则，但是由于 Cell 的存在，我们很优雅地做到了这一点，但是如果你尝试在 Cell 中存放String：
    let c = Cell::new(String::from("asdf"));
    // 编译器会立刻报错，因为 String 没有实现 Copy 特征：
    // let one = c.get();

    // RefCell
    // 由于 Cell 类型针对的是实现了 Copy 特征的值类型，因此在实际开发中，Cell 使用的并不多，因为我们要解决的往往是可变、不可变引用共存导致的问题，此时就需要借助于 RefCell 来达成目的。
    // 我们可以将所有权、借用规则与这些智能指针做一个对比：

    // Rust 规则	                       智能指针带来的额外规则
    // 一个数据只有一个所有者	               Rc/Arc让一个数据可以拥有多个所有者
    // 要么多个不可变借用，要么一个可变借用	      RefCell实现编译期可变、不可变引用共存
    // 违背规则导致编译错误	                   违背规则导致运行时panic

    // RefCell<T> 和内部可变性
    // 内部可变性 ( interior mutability )
    // 内部可变性是 Rust 的设计模式之一
    // 它允许你在只持有不可变引用的前提下对数据进行修改
    //  - 数据结构中使用了 unsafe 代码来绕过 Rust 正常的可变性和借用规则

    // RefCell<T>
    // 与 Rc<T> 不同, RefCell<T> 类型代表了其持有数据的唯一所有权

    // 回忆一下借用规则
    // 在任何给定的时间, 你要么只能拥有一个可变引用, 要么只能拥有任意数量的不可变引用
    // 引用总是有效的

    // RefCell<T> 与 Box<T> 的区别
    // Box<T>                       RefCell<T>
    //  - 编译阶段强制代码遵守借用规则    - 只会在运行时检查借用规则
    //  - 否则出现编译错误              - 否则触发 panic

    // 借用规则在不同阶段进行检查的比较
    // 编译阶段                      运行时
    //  - 尽早暴露问题                 - 暴露问题延后, 甚至到生产环境
    //  - 没有任何运行时开销            - 因借用计数产生些许性能损失
    //  - 对大多数场景是最佳选择         - 实现某些特定的内存安全场景 ( 不可变环境中修改自身数据 )
    //  - 是 Rust 的默认行为

    // Rust 编译器是非常保守的, Rust 代码会拒绝掉所有不符合所有权规则的代码, 哪怕这些代码完全没有任何问题
    // 针对编译器无法理解的代码, 但是开发者可以保证代码的正确性, 那么 RefCell<T> 就有用武之地了

    // RefCell<T>
    // 与 Rc<T> 相似, 只能适用于单线程场景

    // 选择 Box<T>、Rc<T>、RefCell<T> 的依据
    //                      Box<T>            Rc<T>            RefCell<T>
    // 同一数据的所有者        一个              多个              一个
    // 可变性、借用检查        可变、不可变借用    不可变借用         可变、不可变借用
    //                      ( 编译时检查 )     ( 编译时检查 )     运行时检查
    //
    // 其中: 即便 RefCell<T> 本身不可变, 但仍能修改其中存储的值

    // 内部可变性: 可变的借用一个不可变的值
    // 借用规则有一个推论: 无法可变的借用一个不可变的值

    // 可以看出，Rc/Arc 和 RefCell 合在一起，解决了 Rust 中严苛的所有权和借用规则带来的某些场景下难使用的问题。但是它们并不是银弹，例如 RefCell 实际上并没有解决可变引用和引用可以共存的问题，只是将报错从编译期推迟到运行时，从编译器错误变成了 panic 异常：
    let s = RefCell::new(String::from("hello, world"));
    let s1 = s.borrow();
    // let s2 = s.borrow_mut();

    // println!("{},{}", s1, s2);
    // 上面代码在编译期不会报任何错误，你可以顺利运行程序：
    // 但是依然会因为违背了借用规则导致了运行期 panic，这非常像中国的天网，它也许会被罪犯蒙蔽一时，但是并不会被蒙蔽一世，任何导致安全风险的存在都将不能被容忍，法网恢恢，疏而不漏。

    // RefCell 为何存在
    // 相信肯定有读者有疑问了，这么做有任何意义吗？还不如在编译期报错，至少能提前发现问题，而且性能还更好。
    // 存在即合理，究其根因，在于 Rust 编译期的宁可错杀，绝不放过的原则，当编译器不能确定你的代码是否正确时，就统统会判定为错误，因此难免会导致一些误报。
    // 而 RefCell 正是用于你确信代码是正确的，而编译器却发生了误判时。
    // 对于大型的复杂程序，也可以选择使用 RefCell 来让事情简化。例如在 Rust 编译器的ctxt结构体中有大量的 RefCell 类型的 map 字段，主要的原因是：这些 map 会被分散在各个地方的代码片段所广泛使用或修改。由于这种分散在各处的使用方式，导致了管理可变和不可变成为一件非常复杂的任务（甚至不可能），你很容易就碰到编译器抛出来的各种错误。而且 RefCell 的运行时错误在这种情况下也变得非常可爱：一旦有人做了不正确的使用，代码会 panic，然后告诉我们哪些借用冲突了。
    // 总之，当你确信编译器误报但不知道该如何解决时，或者你有一个引用类型，需要被四处使用和修改然后导致借用关系难以管理时，都可以优先考虑使用 RefCell。

    // RefCell 简单总结
    // 1. 与 Cell 用于可 Copy 的值不同，RefCell 用于引用
    // 2. RefCell 只是将借用规则从编译期推迟到程序运行期，并不能帮你绕过这个规则
    // 3. RefCell 适用于编译期误报或者一个引用被在多处代码使用、修改以至于难于管理借用关系时
    // 4. 使用 RefCell 时，违背借用规则会导致运行期的 panic

    // 选择 Cell 还是 RefCell
    // 根据本文的内容，我们可以大概总结下两者的区别：
    // 1. Cell 只适用于 Copy 类型，用于提供值，而 RefCell 用于提供引用
    // 2. Cell 不会 panic，而 RefCell 会

    // 性能比较
    // Cell 没有额外的性能损耗，例如以下两段代码的性能其实是一致的：
    // code snipet 1
    let x = Cell::new(1);
    let y = &x;
    let z = &x;
    x.set(2);
    y.set(3);
    z.set(4);
    println!("{}", x.get());

    // code snipet 2
    // let mut x = 1;
    // let y = &mut x;
    // let z = &mut x;
    // x = 2;
    // *y = 3;
    // *z = 4;
    // println!("{}", x);

    // 虽然性能一致，但代码 1 拥有代码 2 不具有的优势：它能编译成功:)
    // 与 Cell 的 zero cost 不同，RefCell 其实是有一点运行期开销的，原因是它包含了一个字大小的“借用状态”指示器，该指示器在每次运行时借用时都会被修改，进而产生一点开销。
    // 总之，当非要使用内部可变性时，首选 Cell，只有你的类型没有实现 Copy 时，才去选择 RefCell。

    // 内部可变性
    // 之前我们提到 RefCell 具有内部可变性，何为内部可变性？简单来说，对一个不可变的值进行可变借用，但这个并不符合 Rust 的基本借用规则：
    let x = 5;
    // let y = &mut x;
    // 上面的代码会报错，因为我们不能对一个不可变的值进行可变借用，这会破坏 Rust 的安全性保证，相反，你可以对一个可变值进行不可变借用。原因是：当值不可变时，可能会有多个不可变的引用指向它，此时若将修改其中一个为可变的，会造成可变引用与不可变引用共存的情况；
    // 而当值可变时，最多只会有一个可变引用指向它，将其修改为不可变，那么最终依然是只有一个不可变的引用指向它。
    // 虽然基本借用规则是 Rust 的基石，然而在某些场景中，一个值可以在其方法内部被修改，同时对于其它代码不可变，是很有用的：

    // 定义在外部库中的特征
    pub trait Messenger {
        fn send(&self, msg: String);
    }

    pub struct MsgQueue {
        msg_cache: RefCell<Vec<String>>,
    }

    impl Messenger for MsgQueue {
        fn send(&self, msg: String) {
            println!("cache add: {}", msg);
            self.msg_cache.borrow_mut().push(msg)
        }
    }

    let mq = MsgQueue {
        msg_cache: RefCell::new(Vec::new()),
    };

    mq.send("hello, world".to_string());

    // 这个 MQ 功能很弱，但是并不妨碍我们演示内部可变性的核心用法：通过包裹一层 RefCell，成功的让 &self 中的 msg_cache 成为一个可变值，然后实现对其的修改。

    // Rc + RefCell 组合使用
    // 在 Rust 中，一个常见的组合就是 Rc 和 RefCell 在一起使用，前者可以实现一个数据拥有多个所有者，后者可以实现数据的可变性：
    let s = Rc::new(RefCell::new("我很善变，还拥有多个主人".to_string()));
    let s1 = s.clone();
    let s2 = s.clone();
    s2.borrow_mut().push_str(", on yeah!");
    println!("{:?}\n{:?}\n{:?}", s, s1, s2);

    // 上面代码中，我们使用 RefCell<String> 包裹一个字符串，同时通过 Rc 创建了它的三个所有者：s、s1和s2，并且通过其中一个所有者 s2 对字符串内容进行了修改。
    // 由于 Rc 的所有者们共享同一个底层的数据，因此当一个所有者修改了数据时，会导致全部所有者持有的数据都发生了变化。
    // 程序的运行结果也在预料之中：
    // RefCell { value: "我很善变，还拥有多个主人, on yeah!" }
    // RefCell { value: "我很善变，还拥有多个主人, on yeah!" }
    // RefCell { value: "我很善变，还拥有多个主人, on yeah!" }

    // 性能损耗
    // 相信这两者组合在一起使用时，很多人会好奇到底性能如何，下面我们来简单分析下。
    // 首先给出一个大概的结论，这两者结合在一起使用的性能其实非常高，大致相当于没有线程安全版本的 C++ std::shared_ptr 指针，事实上，C++ 这个指针的主要开销也在于原子性这个并发原语上，毕竟线程安全在哪个语言中开销都不小。

    // 内存损耗
    // 两者结合的数据结构与下面类似：
    struct Wrapper<T> {
        // Rc
        strong_count: usize,
        weak_count: usize,

        // Refcell
        borrow_count: isize,

        // 包裹的数据
        item: T,
    }

    // 从上面可以看出，从对内存的影响来看，仅仅多分配了三个usize/isize，并没有其它额外的负担。

    // CPU 损耗
    // 从 CPU 来看，损耗如下：
    // 1. 对 Rc<T> 解引用是免费的（编译期），但是 * 带来的间接取值并不免费
    // 2. 克隆 Rc<T> 需要将当前的引用计数跟 0 和 usize::Max 进行一次比较，然后将计数值加 1
    // 3. 释放（drop） Rc<T> 需要将计数值减 1， 然后跟 0 进行一次比较
    // 4. 对 RefCell 进行不可变借用，需要将 isize 类型的借用计数加 1，然后跟 0 进行比较
    // 5. 对 RefCell 的不可变借用进行释放，需要将 isize 减 1
    // 6. 对 RefCell 的可变借用大致流程跟上面差不多，但是需要先跟 0 比较，然后再减 1
    // 7. 对 RefCell 的可变借用进行释放，需要将 isize 加 1
    // 8. 其实这些细节不必过于关注，只要知道 CPU 消耗也非常低，甚至编译器还会对此进行进一步优化！

    // CPU 缓存 Miss
    // 唯一需要担心的可能就是这种组合数据结构对于 CPU 缓存是否亲和，这个我们无法证明，只能提出来存在这个可能性，最终的性能影响还需要在实际场景中进行测试。
    // 总之，分析这两者组合的性能还挺复杂的，大概总结下：
    // 1. 从表面来看，它们带来的内存和 CPU 损耗都不大
    // 2. 但是由于 Rc 额外的引入了一次间接取值（*），在少数场景下可能会造成性能上的显著损失
    // 3. CPU 缓存可能也不够亲和

    // 通过 Cell::from_mut 解决借用冲突
    // 在 Rust 1.37 版本中新增了两个非常实用的方法：
    // 1. Cell::from_mut，该方法将 &mut T 转为 &Cell<T>
    // 2. Cell::as_slice_of_cells，该方法将 &Cell<[T]> 转为 &[Cell<T>]
    fn is_even(i: i32) -> bool {
        i % 2 == 0
    }

    fn retain_even(nums: &mut Vec<i32>) {
        let slice: &[Cell<i32>] = Cell::from_mut(&mut nums[..]).as_slice_of_cells();

        let mut i = 0;
        for num in slice.iter().filter(|num| is_even(num.get())) {
            slice[i].set(num.get());
            i += 1;
        }

        nums.truncate(i);
    }

    // 此时代码将不会报错，因为 Cell 上的 set 方法获取的是不可变引用 pub fn set(&self, val: T)。
    // 当然，以上代码的本质还是对 Cell 的运用，只不过这两个方法可以很方便的帮我们把 &mut [T] 类型转换成 &[Cell<T>] 类型。
}
