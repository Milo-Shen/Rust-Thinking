use std::cell::{Cell, RefCell};
pub fn cell_refcell() {
    // Cell 和 RefCell
    // Rust 的编译器之严格，可以说是举世无双。特别是在所有权方面，Rust 通过严格的规则来保证所有权和借用的正确性，最终为程序的安全保驾护航。
    // 但是严格是一把双刃剑，带来安全提升的同时，损失了灵活性，有时甚至会让用户痛苦不堪、怨声载道。因此 Rust 提供了 Cell 和 RefCell 用于内部可变性，简而言之，可以在拥有不可变引用的同时修改目标数据，对于正常的代码实现来说，这个是不可能做到的（要么一个可变借用，要么多个不可变借用）。
    // 内部可变性的实现是因为 Rust 使用了 unsafe 来做到这一点，但是对于使用者来说，这些都是透明的，因为这些不安全代码都被封装到了安全的 API 中

    // Cell
    // Cell 和 RefCell 在功能上没有区别，区别在于 Cell<T> 适用于 T 实现 Copy 的情况：
    let c = Cell::new("asdf");
    let one = c.get();
    c.set("qwer1s");
    let two = c.get();
    println!("{},{}", one, two);

    // 以上代码展示了 Cell 的基本用法，有几点值得注意：
    // 1. "asdf" 是 &str 类型，它实现了 Copy 特征
    // 2. c.get 用来取值，c.set 用来设置新值

    // 取到值保存在 one 变量后，还能同时进行修改，这个违背了 Rust 的借用规则，但是由于 Cell 的存在，我们很优雅地做到了这一点，但是如果你尝试在 Cell 中存放String：
    let c = Cell::new(String::from("asdf"));
    // 编译器会立刻报错，因为 String 没有实现 Copy 特征：
    // let one = c.get();

    // RefCell
    // 由于 Cell 类型针对的是实现了 Copy 特征的值类型，因此在实际开发中，Cell 使用的并不多，因为我们要解决的往往是可变、不可变引用共存导致的问题，此时就需要借助于 RefCell 来达成目的。
    // 我们可以将所有权、借用规则与这些智能指针做一个对比：

    // Rust 规则	                       智能指针带来的额外规则
    // 一个数据只有一个所有者	               Rc/Arc让一个数据可以拥有多个所有者
    // 要么多个不可变借用，要么一个可变借用	      RefCell实现编译期可变、不可变引用共存
    // 违背规则导致编译错误	                   违背规则导致运行时panic

    // RefCell<T> 和内部可变性
    // 内部可变性 ( interior mutability )
    // 内部可变性是 Rust 的设计模式之一
    // 它允许你在只持有不可变引用的前提下对数据进行修改
    //  - 数据结构中使用了 unsafe 代码来绕过 Rust 正常的可变性和借用规则

    // RefCell<T>
    // 与 Rc<T> 不同, RefCell<T> 类型代表了其持有数据的唯一所有权

    // 回忆一下借用规则
    // 在任何给定的时间, 你要么只能拥有一个可变引用, 要么只能拥有任意数量的不可变引用
    // 引用总是有效的

    // RefCell<T> 与 Box<T> 的区别
    // Box<T>                       RefCell<T>
    //  - 编译阶段强制代码遵守借用规则    - 只会在运行时检查借用规则
    //  - 否则出现编译错误              - 否则触发 panic

    // 借用规则在不同阶段进行检查的比较
    // 编译阶段                      运行时
    //  - 尽早暴露问题                 - 暴露问题延后, 甚至到生产环境
    //  - 没有任何运行时开销            - 因借用计数产生些许性能损失
    //  - 对大多数场景是最佳选择         - 实现某些特定的内存安全场景 ( 不可变环境中修改自身数据 )
    //  - 是 Rust 的默认行为

    // Rust 编译器是非常保守的, Rust 代码会拒绝掉所有不符合所有权规则的代码, 哪怕这些代码完全没有任何问题
    // 针对编译器无法理解的代码, 但是开发者可以保证代码的正确性, 那么 RefCell<T> 就有用武之地了

    // RefCell<T>
    // 与 Rc<T> 相似, 只能适用于单线程场景

    // 选择 Box<T>、Rc<T>、RefCell<T> 的依据
    //                      Box<T>            Rc<T>            RefCell<T>
    // 同一数据的所有者        一个              多个              一个
    // 可变性、借用检查        可变、不可变借用    不可变借用         可变、不可变借用
    //                      ( 编译时检查 )     ( 编译时检查 )     运行时检查
    //
    // 其中: 即便 RefCell<T> 本身不可变, 但仍能修改其中存储的值

    // 内部可变性: 可变的借用一个不可变的值
    // 借用规则有一个推论: 无法可变的借用一个不可变的值

    // 可以看出，Rc/Arc 和 RefCell 合在一起，解决了 Rust 中严苛的所有权和借用规则带来的某些场景下难使用的问题。但是它们并不是银弹，例如 RefCell 实际上并没有解决可变引用和引用可以共存的问题，只是将报错从编译期推迟到运行时，从编译器错误变成了 panic 异常：
    let s = RefCell::new(String::from("hello, world"));
    let s1 = s.borrow();
    // let s2 = s.borrow_mut();

    // println!("{},{}", s1, s2);
    // 上面代码在编译期不会报任何错误，你可以顺利运行程序：
    // 但是依然会因为违背了借用规则导致了运行期 panic，这非常像中国的天网，它也许会被罪犯蒙蔽一时，但是并不会被蒙蔽一世，任何导致安全风险的存在都将不能被容忍，法网恢恢，疏而不漏。

    // RefCell 为何存在
    // 相信肯定有读者有疑问了，这么做有任何意义吗？还不如在编译期报错，至少能提前发现问题，而且性能还更好。
    // 存在即合理，究其根因，在于 Rust 编译期的宁可错杀，绝不放过的原则，当编译器不能确定你的代码是否正确时，就统统会判定为错误，因此难免会导致一些误报。
    // 而 RefCell 正是用于你确信代码是正确的，而编译器却发生了误判时。
    // 对于大型的复杂程序，也可以选择使用 RefCell 来让事情简化。例如在 Rust 编译器的ctxt结构体中有大量的 RefCell 类型的 map 字段，主要的原因是：这些 map 会被分散在各个地方的代码片段所广泛使用或修改。由于这种分散在各处的使用方式，导致了管理可变和不可变成为一件非常复杂的任务（甚至不可能），你很容易就碰到编译器抛出来的各种错误。而且 RefCell 的运行时错误在这种情况下也变得非常可爱：一旦有人做了不正确的使用，代码会 panic，然后告诉我们哪些借用冲突了。
    // 总之，当你确信编译器误报但不知道该如何解决时，或者你有一个引用类型，需要被四处使用和修改然后导致借用关系难以管理时，都可以优先考虑使用 RefCell。

    // RefCell 简单总结
    // 1. 与 Cell 用于可 Copy 的值不同，RefCell 用于引用
    // 2. RefCell 只是将借用规则从编译期推迟到程序运行期，并不能帮你绕过这个规则
    // 3. RefCell 适用于编译期误报或者一个引用被在多处代码使用、修改以至于难于管理借用关系时
    // 4. 使用 RefCell 时，违背借用规则会导致运行期的 panic

    // 选择 Cell 还是 RefCell
    // 根据本文的内容，我们可以大概总结下两者的区别：
    // 1. Cell 只适用于 Copy 类型，用于提供值，而 RefCell 用于提供引用
    // 2. Cell 不会 panic，而 RefCell 会

    // 性能比较
    // Cell 没有额外的性能损耗，例如以下两段代码的性能其实是一致的：
    // code snipet 1
    let x = Cell::new(1);
    let y = &x;
    let z = &x;
    x.set(2);
    y.set(3);
    z.set(4);
    println!("{}", x.get());

    // code snipet 2
    // let mut x = 1;
    // let y = &mut x;
    // let z = &mut x;
    // x = 2;
    // *y = 3;
    // *z = 4;
    // println!("{}", x);

    // 虽然性能一致，但代码 1 拥有代码 2 不具有的优势：它能编译成功:)
    // 与 Cell 的 zero cost 不同，RefCell 其实是有一点运行期开销的，原因是它包含了一个字大小的“借用状态”指示器，该指示器在每次运行时借用时都会被修改，进而产生一点开销。
    // 总之，当非要使用内部可变性时，首选 Cell，只有你的类型没有实现 Copy 时，才去选择 RefCell。
}
