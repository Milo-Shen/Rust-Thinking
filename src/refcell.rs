use std::cell::Cell;
pub fn cell_refcell() {
    // Cell 和 RefCell
    // Rust 的编译器之严格，可以说是举世无双。特别是在所有权方面，Rust 通过严格的规则来保证所有权和借用的正确性，最终为程序的安全保驾护航。
    // 但是严格是一把双刃剑，带来安全提升的同时，损失了灵活性，有时甚至会让用户痛苦不堪、怨声载道。因此 Rust 提供了 Cell 和 RefCell 用于内部可变性，简而言之，可以在拥有不可变引用的同时修改目标数据，对于正常的代码实现来说，这个是不可能做到的（要么一个可变借用，要么多个不可变借用）。
    // 内部可变性的实现是因为 Rust 使用了 unsafe 来做到这一点，但是对于使用者来说，这些都是透明的，因为这些不安全代码都被封装到了安全的 API 中

    // Cell
    // Cell 和 RefCell 在功能上没有区别，区别在于 Cell<T> 适用于 T 实现 Copy 的情况：
    let c = Cell::new("asdf");
    let one = c.get();
    c.set("qwer1s");
    let two = c.get();
    println!("{},{}", one, two);

    // 以上代码展示了 Cell 的基本用法，有几点值得注意：
    // 1. "asdf" 是 &str 类型，它实现了 Copy 特征
    // 2. c.get 用来取值，c.set 用来设置新值

    // 取到值保存在 one 变量后，还能同时进行修改，这个违背了 Rust 的借用规则，但是由于 Cell 的存在，我们很优雅地做到了这一点，但是如果你尝试在 Cell 中存放String：
    let c = Cell::new(String::from("asdf"));
    // 编译器会立刻报错，因为 String 没有实现 Copy 特征：
    // let one = c.get();

    // RefCell
    // 由于 Cell 类型针对的是实现了 Copy 特征的值类型，因此在实际开发中，Cell 使用的并不多，因为我们要解决的往往是可变、不可变引用共存导致的问题，此时就需要借助于 RefCell 来达成目的。
    // 我们可以将所有权、借用规则与这些智能指针做一个对比：

    // Rust 规则	                       智能指针带来的额外规则
    // 一个数据只有一个所有者	               Rc/Arc让一个数据可以拥有多个所有者
    // 要么多个不可变借用，要么一个可变借用	      RefCell实现编译期可变、不可变引用共存
    // 违背规则导致编译错误	                   违背规则导致运行时panic

    // RefCell<T> 和内部可变性
    // 内部可变性 ( interior mutability )
    // 内部可变性是 Rust 的设计模式之一
    // 它允许你在只持有不可变引用的前提下对数据进行修改
    //  - 数据结构中使用了 unsafe 代码来绕过 Rust 正常的可变性和借用规则

    // RefCell<T>
    // 与 Rc<T> 不同, RefCell<T> 类型代表了其持有数据的唯一所有权

    // 回忆一下借用规则
    // 在任何给定的时间, 你要么只能拥有一个可变引用, 要么只能拥有任意数量的不可变引用
    // 引用总是有效的

    // RefCell<T> 与 Box<T> 的区别
    // Box<T>                       RefCell<T>
    //  - 编译阶段强制代码遵守借用规则    - 只会在运行时检查借用规则
    //  - 否则出现编译错误              - 否则触发 panic

    // 借用规则在不同阶段进行检查的比较
    // 编译阶段                      运行时
    //  - 尽早暴露问题                 - 暴露问题延后, 甚至到生产环境
    //  - 没有任何运行时开销            - 因借用计数产生些许性能损失
    //  - 对大多数场景是最佳选择         - 实现某些特定的内存安全场景 ( 不可变环境中修改自身数据 )
    //  - 是 Rust 的默认行为

    // Rust 编译器是非常保守的, Rust 代码会拒绝掉所有不符合所有权规则的代码, 哪怕这些代码完全没有任何问题
    // 针对编译器无法理解的代码, 但是开发者可以保证代码的正确性, 那么 RefCell<T> 就有用武之地了

    // RefCell<T>
    // 与 Rc<T> 相似, 只能适用于单线程场景

    // 选择 Box<T>、Rc<T>、RefCell<T> 的依据
    //                      Box<T>            Rc<T>            RefCell<T>
    // 同一数据的所有者        一个              多个              一个
    // 可变性、借用检查        可变、不可变借用    不可变借用         可变、不可变借用
    //                      ( 编译时检查 )     ( 编译时检查 )     运行时检查
    //
    // 其中: 即便 RefCell<T> 本身不可变, 但仍能修改其中存储的值

    // 内部可变性: 可变的借用一个不可变的值
    // 借用规则有一个推论: 无法可变的借用一个不可变的值

    // 可以看出，Rc/Arc 和 RefCell 合在一起，解决了 Rust 中严苛的所有权和借用规则带来的某些场景下难使用的问题。但是它们并不是银弹，例如 RefCell 实际上并没有解决可变引用和引用可以共存的问题，只是将报错从编译期推迟到运行时，从编译器错误变成了 panic 异常：
}
