pub fn learn_box() {
    // 智能指针往往是基于结构体实现，它与我们自定义的结构体最大的区别在于它实现了 Deref 和 Drop 特征：
    // 1. Deref 可以让智能指针像引用那样工作，这样你就可以写出同时支持智能指针和引用的代码，例如 *T
    // 2. Drop 允许你指定智能指针超出作用域后自动执行的代码，例如做一些数据清除等收尾工作

    // 智能指针在 Rust 中很常见，我们在本章不会全部讲解，而是挑选几个最常用、最有代表性的进行讲解：
    // 1. Box<T>，可以将值分配到堆上
    // 2. Rc<T>，引用计数类型，允许多所有权存在
    // 3. Ref<T> 和 RefMut<T>，允许将借用规则检查从编译期移动到运行期进行

    // 堆栈的性能
    // 很多人可能会觉得栈的性能肯定比堆高，其实未必。 由于我们在后面的性能专题会专门讲解堆栈的性能问题，因此这里就大概给出结论：
    // 1. 小型数据，在栈上的分配性能和读取性能都要比堆上高
    // 2. 中型数据，栈上分配性能高，但是读取性能和堆上并无区别，因为无法利用寄存器或 CPU 高速缓存，最终还是要经过一次内存寻址
    // 3. 大型数据，只建议在堆上分配和使用
    // 4. 总之，栈的分配速度肯定比堆上快，但是读取速度往往取决于你的数据能不能放入寄存器或 CPU 高速缓存。 因此不要仅仅因为堆上性能不如栈这个印象，就总是优先选择栈，导致代码更复杂的实现。

    // Box 的使用场景
    // 由于 Box 是简单的封装，除了将值存储在堆上外，并没有其它性能上的损耗。而性能和功能往往是鱼和熊掌，因此 Box 相比其它智能指针，功能较为单一，可以在以下场景中使用它：
    // 1. 特意的将数据分配在堆上
    // 2. 数据较大时，又不想在转移所有权时进行数据拷贝
    // 3. 类型的大小在编译期无法确定，但是我们又需要固定大小的类型时
    // 4. 特征对象，用于说明对象实现了一个特征，而不是某个特定的类型

    // 使用 Box<T> 将数据存储在堆上
    // 如果一个变量拥有一个数值 let a = 3，那变量 a 必然是存储在栈上的，那如果我们想要 a 的值存储在堆上就需要使用 Box<T>：
    let a = Box::new(3);
    println!("a = {}", a);

    // 避免栈上数据的拷贝
    // 当栈上数据转移所有权时，实际上是把数据拷贝了一份，最终新旧变量各自拥有不同的数据，因此所有权并未转移。
    // 而堆上则不然，底层数据并不会被拷贝，转移所有权仅仅是复制一份栈中的指针，再将新的指针赋予新的变量，然后让拥有旧指针的变量失效，最终完成了所有权的转移：
    // 在栈上创建一个长度为1000的数组
    let arr = [0; 1000];
    // 将arr所有权转移arr1，由于 `arr` 分配在栈上，因此这里实际上是直接重新深拷贝了一份数据
    let arr1 = arr;

    // arr 和 arr1 都拥有各自的栈上数组，因此不会报错
    println!("{:?}", arr.len());
    println!("{:?}", arr1.len());

    // 在堆上创建一个长度为1000的数组，然后使用一个智能指针指向它
    let arr = Box::new([0; 1000]);
    // 将堆上数组的所有权转移给 arr1，由于数据在堆上，因此仅仅拷贝了智能指针的结构体，底层数据并没有被拷贝
    // 所有权顺利转移给 arr1，arr 不再拥有所有权
    let arr1 = arr;
    println!("{:?}", arr1.len());
    // 由于 arr 不再拥有底层数组的所有权，因此下面代码将报错
    // println!("{:?}", arr.len());
    // 从以上代码，可以清晰看出大块的数据为何应该放入堆中，此时 Box 就成为了我们最好的帮手。

    // 将动态大小类型变为 Sized 固定大小类型
    // 其中一种无法在编译时知道大小的类型是递归类型：在类型定义中又使用到了自身，或者说该类型的值的一部分可以是相同类型的其它值，这种值的嵌套理论上可以无限进行下去，所以 Rust 不知道递归类型需要多少空间
    // 此时若想解决这个问题，就可以使用我们的 Box<T>：
    enum List {
        Cons(i32, Box<List>),
        Nil,
    }

    // 只需要将 List 存储到堆上，然后使用一个智能指针指向它，即可完成从 DST 到 Sized 类型(固定大小类型)的华丽转变。
    // 在 Rust 中，想实现不同类型组成的数组只有两个办法：枚举和特征对象，前者限制较多，因此后者往往是最常用的解决办法。
    // 特征对象
    trait Draw {
        fn draw(&self);
    }

    struct Button {
        id: u32,
    }
    impl Draw for Button {
        fn draw(&self) {
            println!("这是屏幕上第{}号按钮", self.id)
        }
    }

    struct Select {
        id: u32,
    }

    impl Draw for Select {
        fn draw(&self) {
            println!("这个选择框贼难用{}", self.id)
        }
    }

    let elems: Vec<Box<dyn Draw>> = vec![Box::new(Button { id: 1 }), Box::new(Select { id: 2 })];
    for e in elems {
        e.draw()
    }

    // 以上代码将不同类型的 Button 和 Select 包装成 Draw 特征的特征对象，放入一个数组中，Box<dyn Draw> 就是特征对象。
    // 其实，特征也是 DST 类型，而特征对象在做的就是将 DST 类型转换为固定大小类型。

    // Box 内存布局
    // 先来看看 Vec<i32> 的内存布局：
    // 之前提到过 Vec 和 String 都是智能指针，从上图可以看出，该智能指针存储在栈中，然后指向堆上的数组数据。
    // 那如果数组中每个元素都是一个 Box 对象呢 ？来看看 Vec<Box<i32>> 的内存布局：

    // 上面的 B1 代表被 Box 分配到堆上的值 1。
    // 可以看出智能指针 vec2 依然是存储在栈上，然后指针指向一个堆上的数组，该数组中每个元素都是一个 Box 智能指针，最终 Box 智能指针又指向了存储在堆上的实际值。
    // 因此当我们从数组中取出某个元素时，取到的是对应的智能指针 Box，需要对该智能指针进行解引用，才能取出最终的值：
    let arr = vec![Box::new(1), Box::new(2)];
    let (first, second) = (&arr[0], &arr[1]);
    let sum = **first + **second;
    println!("sum = {sum}");

    // 以上代码有几个值得注意的点：
    // 1. 使用 & 借用数组中的元素，否则会报所有权错误
    // 2. 表达式不能隐式的解引用，因此必须使用 ** 做两次解引用，第一次将 &Box<i32> 类型转成 Box<i32>，第二次将 Box<i32> 转成 i32

    // Box::leak
    // Box 中还提供了一个非常有用的关联函数：Box::leak，它可以消费掉 Box 并且强制目标值从内存中泄漏，读者可能会觉得，这有啥用啊？
    // 其实还真有点用，例如，你可以把一个 String 类型，变成一个 'static 生命周期的 &str 类型：
    fn gen_static_str() -> &'static str {
        let mut s = String::new();
        s.push_str("hello, world");
        Box::leak(s.into_boxed_str())
    }
    let s = gen_static_str();
    println!("{}", s);
    // 在之前的代码中，如果 String 创建于函数中，那么返回它的唯一方法就是转移所有权给调用者 fn move_str() -> String，而通过 Box::leak 我们不仅返回了一个 &str 字符串切片，它还是 'static 生命周期的！
    // 要知道真正具有 'static 生命周期的往往都是编译期就创建的值，例如 let v = "hello, world"，这里 v 是直接打包到二进制可执行文件中的，因此该字符串具有 'static 生命周期，再比如 const 常量。
    // 又有读者要问了，我还可以手动为变量标注 'static 啊。其实你标注的 'static 只是用来忽悠编译器的，但是超出作用域，一样被释放回收。而使用 Box::leak 就可以将一个运行期的值转为 'static。
}
