pub fn sized_dst() {
    // Sized 和不定长类型 DST

    // 在 Rust 中类型有多种抽象的分类方式，例如本书之前章节的：基本类型、集合类型、复合类型等。再比如说，如果从编译器何时能获知类型大小的角度出发，可以分成两类:
    // 1. 定长类型( sized )，这些类型的大小在编译时是已知的
    // 2. 不定长类型( unsized )，与定长类型相反，它的大小只有到了程序运行时才能动态获知，这种类型又被称之为 DST

    // 动态大小类型 DST
    // 读者大大们之前学过的几乎所有类型，都是固定大小的类型，包括集合 Vec、String 和 HashMap 等，而动态大小类型刚好与之相反：编译器无法在编译期得知该类型值的大小，只有到了程序运行时，才能动态获知。对于动态类型，我们使用 DST(dynamically sized types)或者 unsized 类型来称呼它。
    // 上述的这些集合虽然底层数据可动态变化，感觉像是动态大小的类型。但是实际上，这些底层数据只是保存在堆上，在栈中还存有一个引用类型，该引用包含了集合的内存地址、元素数目、分配空间信息，通过这些信息，编译器对于该集合的实际大小了若指掌，最最重要的是：栈上的引用类型是固定大小的，因此它们依然是固定大小的类型。
    // 正因为编译器无法在编译期获知类型大小，若你试图在代码中直接使用 DST 类型，将无法通过编译。

    // 试图创建动态大小的数组
    // fn my_function(n: usize) {
    //     let array = [123; n];
    // }
    // 以上代码就会报错(错误输出的内容并不是因为 DST，但根本原因是类似的)，因为 n 在编译期无法得知，而数组类型的一个组成部分就是长度，长度变为动态的，自然类型就变成了 unsized 。

    // 切片
    // Rust 语言特性内置的 str 和 [u8] 类型都是切片，前者是字符串切片，后者是数组切片，下面我们来尝试下使用 str ：
    // let string: str = "banana";
    // let a: [u8];
    // 编译器准确的告诉了我们原因：str 字符串切片它是 DST 动态大小类型，这意味着编译器无法在编译期知道 str 类型的大小，只有到了运行期才能动态获知，这对于强类型、强安全的 Rust 语言来说是不可接受的。
    // 也就是说，我们无法直接使用 str，而对于 [u8] 也是类似的。
    // 总之，我们可以总结出一个结论：在 Rust 中，所有的切片都是动态大小类型，它们都无法直接被使用。

    // 为何切片是动态大小类型
    // 原因在于底层的切片长度是可以动态变化的，而编译器无法在编译期得知它的具体的长度，因此该类型无法被分配在栈上，只能分配在堆上。

    // 为何切片只能通过引用来使用
    // 既然切片只能分配到堆上，我们就无法直接使用它，大家可以想想，所有分配在堆上的数据，是不是都是通过一个在栈上的引用来访问的？切片也不例外。

    // 为何切片引用可以存储在栈上
    // 切片引用是一个宽指针，存储在栈上，指向了堆上的切片数据，该引用包含了切片的起始位置和长度，而且最重要的是，类似于指针，引用的大小是固定的(起始位置和长度都是整形)，因此它才可以存储在栈上。

    // 有没有可以存储在栈上的
    // 有，使用固定长度的数组: let a: [i8;4] = [1,2,3,4];，注意看，数组的类型与切片是不同的，前者的类型带有长度：[i8;4]，而后者仅仅是 [i8]。

    // 切片引用
    // 那么问题来了，该如何使用切片呢？
    // 何以解忧，唯有引用。由于引用类型的大小在编译期是已知的，因此在 Rust 中，如果要使用切片，就必须要使用它的引用。
    // str 切片的引用类型是 &str，而 [i32] 的引用类型是 &[i32]，相信聪明的读者已经看出来了，&str 和 &[i32] 都是我们非常常用的类型，例如:

    let s1: &str = "banana";
    let s2: &str = &String::from("banana");
    let arr = [1, 2, 3, 4, 5];
    let s3: &[i32] = &arr[1..3];
    // 这段代码就可以正常通过，原因在于这些切片引用的大小在编译器都是已知的。

    // 我们常常说使用切片，实际上我们在用的是切片的引用，我们也在频繁说使用字符串，实际上我们在使用的也是字符串切片的引用。
    // 总之，切片在 Rust 中是动态大小类型 DST，是无法被我们直接使用的，而我们在使用的都是切片的引用。
    // 但是出于方便，我们往往不会说使用切片引用，而是直接说使用字符串切片或数组切片，实际上，这时指代的都是切片的引用！

    // str
    // 考虑一下这个类型：str，感觉有点眼生？是的，它既不是 String 动态字符串，也不是 &str 字符串切片，而是一个 str。它是一个动态类型，同时还是 String 和 &str 的底层数据类型。 由于 str 是动态类型，因此它的大小直到运行期才知道，下面的代码会因此报错：
    // error
    // let s1: str = "Hello there!";
    // let s2: str = "How's it going?";

    // ok
    let s3: &str = "on?";
}
