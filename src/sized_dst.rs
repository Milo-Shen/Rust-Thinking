pub fn sized_dst() {
    // Sized 和不定长类型 DST

    // 在 Rust 中类型有多种抽象的分类方式，例如本书之前章节的：基本类型、集合类型、复合类型等。再比如说，如果从编译器何时能获知类型大小的角度出发，可以分成两类:
    // 1. 定长类型( sized )，这些类型的大小在编译时是已知的
    // 2. 不定长类型( unsized )，与定长类型相反，它的大小只有到了程序运行时才能动态获知，这种类型又被称之为 DST

    // 动态大小类型 DST
    // 读者大大们之前学过的几乎所有类型，都是固定大小的类型，包括集合 Vec、String 和 HashMap 等，而动态大小类型刚好与之相反：编译器无法在编译期得知该类型值的大小，只有到了程序运行时，才能动态获知。对于动态类型，我们使用 DST(dynamically sized types)或者 unsized 类型来称呼它。
    // 上述的这些集合虽然底层数据可动态变化，感觉像是动态大小的类型。但是实际上，这些底层数据只是保存在堆上，在栈中还存有一个引用类型，该引用包含了集合的内存地址、元素数目、分配空间信息，通过这些信息，编译器对于该集合的实际大小了若指掌，最最重要的是：栈上的引用类型是固定大小的，因此它们依然是固定大小的类型。
    // 正因为编译器无法在编译期获知类型大小，若你试图在代码中直接使用 DST 类型，将无法通过编译。

    // 试图创建动态大小的数组
    // fn my_function(n: usize) {
    //     let array = [123; n];
    // }
    // 以上代码就会报错(错误输出的内容并不是因为 DST，但根本原因是类似的)，因为 n 在编译期无法得知，而数组类型的一个组成部分就是长度，长度变为动态的，自然类型就变成了 unsized 。

    // 切片
    // Rust 语言特性内置的 str 和 [u8] 类型都是切片，前者是字符串切片，后者是数组切片，下面我们来尝试下使用 str ：
    // let string: str = "banana";
    // let a: [u8];
    // 编译器准确的告诉了我们原因：str 字符串切片它是 DST 动态大小类型，这意味着编译器无法在编译期知道 str 类型的大小，只有到了运行期才能动态获知，这对于强类型、强安全的 Rust 语言来说是不可接受的。
    // 也就是说，我们无法直接使用 str，而对于 [u8] 也是类似的。
    // 总之，我们可以总结出一个结论：在 Rust 中，所有的切片都是动态大小类型，它们都无法直接被使用。

    // 为何切片是动态大小类型
    // 原因在于底层的切片长度是可以动态变化的，而编译器无法在编译期得知它的具体的长度，因此该类型无法被分配在栈上，只能分配在堆上。

    // 为何切片只能通过引用来使用
    // 既然切片只能分配到堆上，我们就无法直接使用它，大家可以想想，所有分配在堆上的数据，是不是都是通过一个在栈上的引用来访问的？切片也不例外。

    // 为何切片引用可以存储在栈上
    // 切片引用是一个宽指针，存储在栈上，指向了堆上的切片数据，该引用包含了切片的起始位置和长度，而且最重要的是，类似于指针，引用的大小是固定的(起始位置和长度都是整形)，因此它才可以存储在栈上。

    // 有没有可以存储在栈上的
    // 有，使用固定长度的数组: let a: [i8;4] = [1,2,3,4];，注意看，数组的类型与切片是不同的，前者的类型带有长度：[i8;4]，而后者仅仅是 [i8]。

    // 切片引用
    // 那么问题来了，该如何使用切片呢？
    // 何以解忧，唯有引用。由于引用类型的大小在编译期是已知的，因此在 Rust 中，如果要使用切片，就必须要使用它的引用。
    // str 切片的引用类型是 &str，而 [i32] 的引用类型是 &[i32]，相信聪明的读者已经看出来了，&str 和 &[i32] 都是我们非常常用的类型，例如:

    let s1: &str = "banana";
    let s2: &str = &String::from("banana");
    let arr = [1, 2, 3, 4, 5];
    let s3: &[i32] = &arr[1..3];
    // 这段代码就可以正常通过，原因在于这些切片引用的大小在编译器都是已知的。

    // 我们常常说使用切片，实际上我们在用的是切片的引用，我们也在频繁说使用字符串，实际上我们在使用的也是字符串切片的引用。
    // 总之，切片在 Rust 中是动态大小类型 DST，是无法被我们直接使用的，而我们在使用的都是切片的引用。
    // 但是出于方便，我们往往不会说使用切片引用，而是直接说使用字符串切片或数组切片，实际上，这时指代的都是切片的引用！

    // str
    // 考虑一下这个类型：str，感觉有点眼生？是的，它既不是 String 动态字符串，也不是 &str 字符串切片，而是一个 str。它是一个动态类型，同时还是 String 和 &str 的底层数据类型。 由于 str 是动态类型，因此它的大小直到运行期才知道，下面的代码会因此报错：
    // error
    // let s1: str = "Hello there!";
    // let s2: str = "How's it going?";

    // ok
    let s3: &str = "on?";
    // Rust 需要明确地知道一个特定类型的值占据了多少内存空间，同时该类型的所有值都必须使用相同大小的内存。如果 Rust 允许我们使用这种动态类型，那么这两个 str 值就需要占用同样大小的内存，这显然是不现实的: s1 占用了 12 字节，s2 占用了 15 字节，总不至于为了满足同样的内存大小，用空白字符去填补字符串吧？
    // 所以，我们只有一条路走，那就是给它们一个固定大小的类型：&str。那么为何字符串切片 &str 就是固定大小呢？因为它的引用存储在栈上，具有固定大小(类似指针)，同时它指向的数据存储在堆中，也是已知的大小，再加上 &str 引用中包含有堆上数据内存地址、长度等信息，因此最终可以得出字符串切片是固定大小类型的结论。
    // 与 &str 类似，String 字符串也是固定大小的类型。
    // 正是因为 &str 的引用有了底层堆数据的明确信息，它才是固定大小类型。假设如果它没有这些信息呢？那它也将变成一个动态类型。因此，将动态数据固定化的秘诀就是使用引用指向这些动态数据，然后在引用中存储相关的内存位置、长度等信息。

    // 特征对象
    // fn foobar_1(thing: &dyn MyThing) {}     // OK
    // fn foobar_2(thing: Box<dyn MyThing>) {} // OK
    // fn foobar_3(thing: MyThing) {}          // ERROR!

    // 总结：只能间接使用的 DST
    // Rust 中常见的 DST 类型有: str、[T]、dyn Trait，它们都无法单独被使用，必须要通过引用或者 Box 来间接使用 。
    // 我们之前已经见过，使用 Box 将一个没有固定大小的特征变成一个有固定大小的特征对象，那能否故技重施，将 str 封装成一个固定大小类型？留个悬念先，我们来看看 Sized 特征。

    // Sized 特征
    // 既然动态类型的问题这么大，那么在使用泛型时，Rust 如何保证我们的泛型参数是固定大小的类型呢？例如以下泛型函数：
    fn generic<T>(t: T) {}

    // 该函数很简单，就一个泛型参数 T，那么如何保证 T 是固定大小的类型？仔细回想下，貌似在之前的课程章节中，我们也没有做过任何事情去做相关的限制，那 T 怎么就成了固定大小的类型了？奥秘在于编译器自动帮我们加上了 Sized 特征约束：
    fn generic1<T: Sized>(t: T) {}

    // 在上面，Rust 自动添加的特征约束 T: Sized，表示泛型函数只能用于一切实现了 Sized 特征的类型上，而所有在编译时就能知道其大小的类型，都会自动实现 Sized 特征，例如。。。。也没啥好例如的，你能想到的几乎所有类型都实现了 Sized 特征，除了上面那个坑坑的 str，哦，还有特征。
    // 每一个特征都是一个可以通过名称来引用的动态大小类型。因此如果想把特征作为具体的类型来传递给函数，你必须将其转换成一个特征对象：诸如 &dyn Trait 或者 Box<dyn Trait> (还有 Rc<dyn Trait>)这些引用类型。

    // 现在还有一个问题：假如想在泛型函数中使用动态数据类型怎么办？可以使用 ?Sized 特征(不得不说这个命名方式很 Rusty，竟然有点幽默)：
    fn generic3<T: ?Sized>(t: &T) {}
    // ?Sized 特征用于表明类型 T 既有可能是固定大小的类型，也可能是动态大小的类型。还有一点要注意的是，函数参数类型从 T 变成了 &T，因为 T 可能是动态大小的，因此需要用一个固定大小的指针(引用)来包裹它。

    // Box<str>
    // 在结束前，再来看看之前遗留的问题：使用 Box 可以将一个动态大小的特征变成一个具有固定大小的特征对象，能否故技重施，将 str 封装成一个固定大小类型？
    // 先回想下，章节前面的内容介绍过该如何把一个动态大小类型转换成固定大小的类型： 使用引用指向这些动态数据，然后在引用中存储相关的内存位置、长度等信息。
    // 好的，根据这个，我们来一起推测。首先，Box<str> 使用了一个引用来指向 str，嗯，满足了第一个条件。但是第二个条件呢？Box 中有该 str 的长度信息吗？
    // 显然是 No。那为什么特征就可以变成特征对象？其实这个还蛮复杂的，简单来说，对于特征对象，编译器无需知道它具体是什么类型，只要知道它能调用哪几个方法即可，因此编译器帮我们实现了剩下的一切。
    // let s1: Box<str> = Box::new("Hello there!" as str);

    // 提示得很清晰，不知道 str 的大小，因此无法使用这种语法进行 Box 进装，但是你可以这么做:
    // 主动转换成 str 的方式不可行，但是可以让编译器来帮我们完成，只要告诉它我们需要的类型即可。
    let s1: Box<str> = "Hello there!".into();
}
